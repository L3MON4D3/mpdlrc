// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o mpd_bundle.go github.com/fhs/gompd/v2/mpd

// Package mpd provides the client side interface to MPD (Music Player Daemon).
// The protocol reference can be found at http://www.musicpd.org/doc/protocol/index.html
//

package client

import (
	"container/list"
	"errors"
	"fmt"
	"io"
	"net/textproto"
	"strconv"
	"strings"
	"time"
)

// Quote quotes string VALUES in the format understood by MPD.
// See: https://github.com/MusicPlayerDaemon/MPD/blob/master/src/util/Tokenizer.cxx
// NB: this function shouldn't be used on the PROTOCOL LEVEL because it considers single quotes special chars and
// escapes them.
func mpd_quote(s string) string {
	q := make([]byte, 2+2*len(s))
	i := 0
	q[i], i = '"', i+1
	for _, c := range []byte(s) {
		// We need to escape single/double quotes and a backslash by prepending them with a '\'
		if c == '"' || c == '\\' || c == '\'' {
			q[i] = '\\'
			i++
		}
		q[i] = c
		i++
	}
	q[i], i = '"', i+1
	return string(q[:i])
}

// Quote quotes each string of args in the format understood by MPD.
// See: https://github.com/MusicPlayerDaemon/MPD/blob/master/src/util/Tokenizer.cxx
func mpd_quoteArgs(args []string) string {
	quoted := make([]string, len(args))
	for index, arg := range args {
		quoted[index] = mpd_quote(arg)
	}
	return strings.Join(quoted, " ")
}

// Client represents a client connection to a MPD server.
type mpd_Client struct {
	text    *textproto.Conn
	version string
}

// Error represents an error returned by the MPD server.
// It contains the error number, the index of the causing command in the command list,
// the name of the command in the command list and the error message.
type mpd_Error struct {
	Code             mpd_ErrorCode
	CommandListIndex int
	CommandName      string
	Message          string
}

// ErrorCode is the error code of a Error.
type mpd_ErrorCode int

// ErrorCodes as defined in MPD source (https://www.musicpd.org/doc/api/html/Ack_8hxx_source.html)
// version 0.21.
const (
	mpd_ErrorNotList       mpd_ErrorCode = 1
	mpd_ErrorArg           mpd_ErrorCode = 2
	mpd_ErrorPassword      mpd_ErrorCode = 3
	mpd_ErrorPermission    mpd_ErrorCode = 4
	mpd_ErrorUnknown       mpd_ErrorCode = 5
	mpd_ErrorNoExist       mpd_ErrorCode = 50
	mpd_ErrorPlaylistMax   mpd_ErrorCode = 51
	mpd_ErrorSystem        mpd_ErrorCode = 52
	mpd_ErrorPlaylistLoad  mpd_ErrorCode = 53
	mpd_ErrorUpdateAlready mpd_ErrorCode = 54
	mpd_ErrorPlayerSync    mpd_ErrorCode = 55
	mpd_ErrorExist         mpd_ErrorCode = 56
)

func (e mpd_Error) Error() string {
	if e.CommandName != "" {
		return fmt.Sprintf("command '%s' failed: %s", e.CommandName, e.Message)
	}
	return e.Message
}

// Attrs is a set of attributes returned by MPD.
type mpd_Attrs map[string]string

// Dial connects to MPD listening on address addr (e.g. "127.0.0.1:6600")
// on network network (e.g. "tcp").
func mpd_Dial(network, addr string) (c *mpd_Client, err error) {
	text, err := textproto.Dial(network, addr)
	if err != nil {
		return nil, err
	}
	line, err := text.ReadLine()
	if err != nil {
		return nil, err
	}
	if line[0:6] != "OK MPD" {
		return nil, textproto.ProtocolError("no greeting")
	}
	return &mpd_Client{text: text, version: line[7:]}, nil
}

// DialAuthenticated connects to MPD listening on address addr (e.g. "127.0.0.1:6600")
// on network network (e.g. "tcp"). It then authenticates with MPD
// using the plaintext password password if it's not empty.
func mpd_DialAuthenticated(network, addr, password string) (c *mpd_Client, err error) {
	c, err = mpd_Dial(network, addr)
	if err == nil && len(password) > 0 {
		err = c.Command("password %s", password).OK()
	}
	return c, err
}

// Version returns the protocol version used as provided during the handshake.
func (c *mpd_Client) Version() string {
	return c.version
}

// We are reimplemeting Cmd() and PrintfLine() from textproto here, because
// the original functions append CR-LF to the end of commands. This behavior
// violates the MPD protocol: Commands must be terminated by '\n'.
func (c *mpd_Client) cmd(format string, args ...interface{}) (uint, error) {
	id := c.text.Next()
	c.text.StartRequest(id)
	defer c.text.EndRequest(id)
	if err := c.printfLine(format, args...); err != nil {
		return 0, err
	}
	return id, nil
}

func (c *mpd_Client) printfLine(format string, args ...interface{}) error {
	fmt.Fprintf(c.text.W, format, args...)
	c.text.W.WriteByte('\n')
	return c.text.W.Flush()
}

// Close terminates the connection with MPD.
func (c *mpd_Client) Close() (err error) {
	if c.text != nil {
		c.printfLine("close")
		err = c.text.Close()
		c.text = nil
	}
	return
}

// Ping sends a no-op message to MPD. It's useful for keeping the connection alive.
func (c *mpd_Client) Ping() error {
	return c.Command("ping").OK()
}

func (c *mpd_Client) readList(key string) (list []string, err error) {
	list = []string{}
	key += ": "
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}
		if line == "OK" {
			break
		}
		if !strings.HasPrefix(line, key) {
			return nil, textproto.ProtocolError("unexpected: " + line)
		}
		list = append(list, line[len(key):])
	}
	return
}

func (c *mpd_Client) readLine() (string, error) {
	line, err := c.text.ReadLine()
	if err != nil {
		return "", err
	}
	if strings.HasPrefix(line, "ACK ") {
		cur := line[4:]
		var code, idx int
		if strings.HasPrefix(cur, "[") {
			sep := strings.Index(cur, "@")
			end := strings.Index(cur, "] ")
			if sep > 0 && end > 0 {
				code, err = strconv.Atoi(cur[1:sep])
				if err != nil {
					return "", err
				}
				idx, err = strconv.Atoi(cur[sep+1 : end])
				if err != nil {
					return "", err
				}
				cur = cur[end+2:]
			}
		}
		var cmd string
		if strings.HasPrefix(cur, "{") {
			if end := strings.Index(cur, "} "); end > 0 {
				cmd = cur[1:end]
				cur = cur[end+2:]
			}
		}
		msg := strings.TrimSpace(cur)
		return "", mpd_Error{
			Code:             mpd_ErrorCode(code),
			CommandListIndex: idx,
			CommandName:      cmd,
			Message:          msg,
		}
	}
	return line, nil
}

func (c *mpd_Client) readBytes(length int) ([]byte, error) {
	// Read the entire chunk of data. ReadFull() makes sure the data length matches the expectation
	data := make([]byte, length)
	if _, err := io.ReadFull(c.text.R, data); err != nil {
		return nil, err
	}

	// Verify there's a linebreak afterwards and skip it
	termByte, err := c.text.R.ReadByte()
	if err != nil {
		return nil, textproto.ProtocolError("failed to read binary data terminator: " + err.Error())
	}
	if termByte != '\n' {
		return nil, textproto.ProtocolError(fmt.Sprintf("wrong binary data terminator: want 0x0a, got %x", termByte))
	}
	return data, nil
}

func (c *mpd_Client) readAttrsList(startKey string) (attrs []mpd_Attrs, err error) {
	attrs = []mpd_Attrs{}
	startKey += ": "
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}
		if line == "OK" {
			break
		}
		if strings.HasPrefix(line, startKey) { // new entry begins
			attrs = append(attrs, mpd_Attrs{})
		}
		if len(attrs) == 0 {
			return nil, textproto.ProtocolError("unexpected: " + line)
		}
		i := strings.Index(line, ": ")
		if i < 0 {
			return nil, textproto.ProtocolError("can't parse line: " + line)
		}
		attrs[len(attrs)-1][line[0:i]] = line[i+2:]
	}
	return attrs, nil
}

func (c *mpd_Client) readAttrs(terminator string) (attrs mpd_Attrs, err error) {
	attrs = make(mpd_Attrs)
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}
		if line == terminator {
			break
		}
		z := strings.Index(line, ": ")
		if z < 0 {
			return nil, textproto.ProtocolError("can't parse line: " + line)
		}
		key := line[0:z]
		attrs[key] = line[z+2:]
	}
	return
}

func (c *mpd_Client) readBinary() ([]byte, int, error) {
	size := -1
	for {
		line, err := c.readLine()
		switch {
		case err != nil:
			return nil, 0, err

		// Check for the size key
		case strings.HasPrefix(line, "size: "):
			if size, err = strconv.Atoi(line[6:]); err != nil {
				return nil, 0, textproto.ProtocolError("failed to parse size: " + err.Error())
			}

		// Check for the binary key
		case strings.HasPrefix(line, "binary: "):
			length := -1
			if length, err = strconv.Atoi(line[8:]); err != nil {
				return nil, 0, textproto.ProtocolError("failed to parse binary: " + err.Error())
			}

			// If no size is given, assume it's equal to the provided data's length
			if size < 0 {
				size = length
			}

			// The binary data must follow the 'binary:' key
			data, err := c.readBytes(length)
			if err != nil {
				return nil, 0, err
			}

			// The binary data must be followed by the "OK" line
			if s, err := c.readLine(); err != nil {
				return nil, 0, err
			} else if s != "OK" {
				return nil, 0, textproto.ProtocolError("expected 'OK', got " + s)
			}
			return data, size, nil

		// No more data. Obviously, no binary data encountered
		case line == "", line == "OK":
			return nil, 0, textproto.ProtocolError("no binary data found in response")
		}
	}
}

// CurrentSong returns information about the current song in the playlist.
func (c *mpd_Client) CurrentSong() (mpd_Attrs, error) {
	return c.Command("currentsong").Attrs()
}

// Status returns information about the current status of MPD.
func (c *mpd_Client) Status() (mpd_Attrs, error) {
	return c.Command("status").Attrs()
}

// Stats displays statistics (number of artists, songs, playtime, etc)
func (c *mpd_Client) Stats() (mpd_Attrs, error) {
	return c.Command("stats").Attrs()
}

func (c *mpd_Client) readOKLine(terminator string) (err error) {
	line, err := c.readLine()
	if err != nil {
		return
	}
	if line == terminator {
		return nil
	}
	return textproto.ProtocolError("unexpected response: " + line)
}

func (c *mpd_Client) idle(subsystems ...string) ([]string, error) {
	return c.Command("idle %s", mpd_Quoted(strings.Join(subsystems, " "))).Strings("changed")
}

func (c *mpd_Client) noIdle() (err error) {
	id, err := c.cmd("noidle")
	if err == nil {
		c.text.StartResponse(id)
		c.text.EndResponse(id)
	}
	return
}

//
// Playback control
//

// Next plays next song in the playlist.
func (c *mpd_Client) Next() error {
	return c.Command("next").OK()
}

// Pause pauses playback if pause is true; resumes playback otherwise.
func (c *mpd_Client) Pause(pause bool) error {
	if pause {
		return c.Command("pause 1").OK()
	}
	return c.Command("pause 0").OK()
}

// Play starts playing the song at playlist position pos. If pos is negative,
// start playing at the current position in the playlist.
func (c *mpd_Client) Play(pos int) error {
	if pos < 0 {
		return c.Command("play").OK()
	}
	return c.Command("play %d", pos).OK()
}

// PlayID plays the song identified by id. If id is negative, start playing
// at the current position in playlist.
func (c *mpd_Client) PlayID(id int) error {
	if id < 0 {
		return c.Command("playid").OK()
	}
	return c.Command("playid %d", id).OK()
}

// Previous plays previous song in the playlist.
func (c *mpd_Client) Previous() error {
	return c.Command("previous").OK()
}

// Seek seeks to the position time (in seconds) of the song at playlist position pos.
// Deprecated: Use SeekPos instead.
func (c *mpd_Client) Seek(pos, time int) error {
	return c.Command("seek %d %d", pos, time).OK()
}

// SeekID is identical to Seek except the song is identified by it's id
// (not position in playlist).
// Deprecated: Use SeekSongID instead.
func (c *mpd_Client) SeekID(id, time int) error {
	return c.Command("seekid %d %d", id, time).OK()
}

// SeekPos seeks to the position d of the song at playlist position pos.
func (c *mpd_Client) SeekPos(pos int, d time.Duration) error {
	return c.Command("seek %d %f", pos, d.Seconds()).OK()
}

// SeekSongID seeks to the position d of the song identified by id.
func (c *mpd_Client) SeekSongID(id int, d time.Duration) error {
	return c.Command("seekid %d %f", id, d.Seconds()).OK()
}

// SeekCur seeks to the position d within the current song.
// If relative is true, then the time is relative to the current playing position.
func (c *mpd_Client) SeekCur(d time.Duration, relative bool) error {
	if relative {
		return c.Command("seekcur %+f", d.Seconds()).OK()
	}
	return c.Command("seekcur %f", d.Seconds()).OK()
}

// Stop stops playback.
func (c *mpd_Client) Stop() error {
	return c.Command("stop").OK()
}

// SetVolume sets the volume to volume. The range of volume is 0-100.
func (c *mpd_Client) SetVolume(volume int) error {
	return c.Command("setvol %d", volume).OK()
}

// Random enables random playback, if random is true, disables it otherwise.
func (c *mpd_Client) Random(random bool) error {
	if random {
		return c.Command("random 1").OK()
	}
	return c.Command("random 0").OK()
}

// Repeat enables repeat mode, if repeat is true, disables it otherwise.
func (c *mpd_Client) Repeat(repeat bool) error {
	if repeat {
		return c.Command("repeat 1").OK()
	}
	return c.Command("repeat 0").OK()
}

// Single enables single song mode, if single is true, disables it otherwise.
func (c *mpd_Client) Single(single bool) error {
	if single {
		return c.Command("single 1").OK()
	}
	return c.Command("single 0").OK()
}

// Consume enables consume mode, if consume is true, disables it otherwise.
func (c *mpd_Client) Consume(consume bool) error {
	if consume {
		return c.Command("consume 1").OK()
	}
	return c.Command("consume 0").OK()
}

//
// Playlist related functions
//

// PlaylistInfo returns attributes for songs in the current playlist. If
// both start and end are negative, it does this for all songs in
// playlist. If end is negative but start is positive, it does it for the
// song at position start. If both start and end are positive, it does it
// for positions in range [start, end).
func (c *mpd_Client) PlaylistInfo(start, end int) ([]mpd_Attrs, error) {
	var cmd *mpd_Command
	switch {
	case start < 0 && end < 0:
		// Request all playlist items.
		cmd = c.Command("playlistinfo")
	case start >= 0 && end >= 0:
		// Request this range of playlist items.
		cmd = c.Command("playlistinfo %d:%d", start, end)
	case start >= 0 && end < 0:
		// Request the single playlist item at this position.
		cmd = c.Command("playlistinfo %d", start)
	case start < 0 && end >= 0:
		return nil, errors.New("negative start index")
	default:
		panic("unreachable")
	}
	return cmd.AttrsList("file")
}

// SetPriority set the priority of the specified songs. If end is negative but
// start is non-negative, it does it for the song at position start. If both
// start and end are non-negative, it does it for positions in range
// [start, end).
func (c *mpd_Client) SetPriority(priority, start, end int) error {
	switch {
	case start < 0 && end < 0:
		return errors.New("negative start and end index")
	case start >= 0 && end >= 0:
		// Update the prio for this range of playlist items.
		return c.Command("prio %d %d:%d", priority, start, end).OK()
	case start >= 0 && end < 0:
		// Update the prio for a single playlist item at this position.
		return c.Command("prio %d %d", priority, start).OK()
	case start < 0 && end >= 0:
		return errors.New("negative start index")
	default:
		panic("unreachable")
	}
}

// SetPriorityID sets the prio of the song with the given id.
func (c *mpd_Client) SetPriorityID(priority, id int) error {
	return c.Command("prioid %d %d", priority, id).OK()
}

// Delete deletes songs from playlist. If both start and end are positive,
// it deletes those at positions in range [start, end). If end is negative,
// it deletes the song at position start.
func (c *mpd_Client) Delete(start, end int) error {
	if start < 0 {
		return errors.New("negative start index")
	}
	if end < 0 {
		return c.Command("delete %d", start).OK()
	}
	return c.Command("delete %d:%d", start, end).OK()
}

// DeleteID deletes the song identified by id.
func (c *mpd_Client) DeleteID(id int) error {
	return c.Command("deleteid %d", id).OK()
}

// Move moves the songs between the positions start and end to the new position
// position. If end is negative, only the song at position start is moved.
func (c *mpd_Client) Move(start, end, position int) error {
	if start < 0 {
		return errors.New("negative start index")
	}
	if end < 0 {
		return c.Command("move %d %d", start, position).OK()
	}
	return c.Command("move %d:%d %d", start, end, position).OK()
}

// MoveID moves songid to position on the plyalist.
func (c *mpd_Client) MoveID(songid, position int) error {
	return c.Command("moveid %d %d", songid, position).OK()
}

// Add adds the file/directory uri to playlist. Directories add recursively.
func (c *mpd_Client) Add(uri string) error {
	return c.Command("add %s", uri).OK()
}

// AddID adds the file/directory uri to playlist and returns the identity
// id of the song added. If pos is positive, the song is added to position
// pos.
func (c *mpd_Client) AddID(uri string, pos int) (int, error) {
	var cmd *mpd_Command
	if pos >= 0 {
		cmd = c.Command("addid %s %d", uri, pos)
	} else {
		cmd = c.Command("addid %s", uri)
	}
	attrs, err := cmd.Attrs()
	if err != nil {
		return -1, err
	}
	tok, ok := attrs["Id"]
	if !ok {
		return -1, textproto.ProtocolError("addid did not return Id")
	}
	return strconv.Atoi(tok)
}

// Clear clears the current playlist.
func (c *mpd_Client) Clear() error {
	return c.Command("clear").OK()
}

// Shuffle shuffles the tracks from position start to position end in the
// current playlist. If start or end is negative, the whole playlist is
// shuffled.
func (c *mpd_Client) Shuffle(start, end int) error {
	if start < 0 || end < 0 {
		return c.Command("shuffle").OK()
	}
	return c.Command("shuffle %d:%d", start, end).OK()
}

// Database related commands

// GetFiles returns the entire list of files in MPD database.
func (c *mpd_Client) GetFiles() ([]string, error) {
	return c.Command("list file").Strings("file")
}

// Update updates MPD's database: find new files, remove deleted files, update
// modified files. uri is a particular directory or file to update. If it is an
// empty string, everything is updated.
//
// The returned jobID identifies the update job, enqueued by MPD.
func (c *mpd_Client) Update(uri string) (jobID int, err error) {
	id, err := c.cmd("update %s", mpd_quote(uri))
	if err != nil {
		return
	}
	c.text.StartResponse(id)
	defer c.text.EndResponse(id)

	line, err := c.readLine()
	if err != nil {
		return
	}
	if !strings.HasPrefix(line, "updating_db: ") {
		return 0, textproto.ProtocolError("unexpected response: " + line)
	}
	jobID, err = strconv.Atoi(line[13:])
	if err != nil {
		return
	}
	return jobID, c.readOKLine("OK")
}

// Rescan updates MPD's database like Update, but it also rescans unmodified
// files. uri is a particular directory or file to update. If it is an empty
// string, everything is updated.
//
// The returned jobID identifies the update job, enqueued by MPD.
func (c *mpd_Client) Rescan(uri string) (jobID int, err error) {
	id, err := c.cmd("rescan %s", mpd_quote(uri))
	if err != nil {
		return
	}
	c.text.StartResponse(id)
	defer c.text.EndResponse(id)

	line, err := c.readLine()
	if err != nil {
		return
	}
	if !strings.HasPrefix(line, "updating_db: ") {
		return 0, textproto.ProtocolError("unexpected response: " + line)
	}
	jobID, err = strconv.Atoi(line[13:])
	if err != nil {
		return
	}
	return jobID, c.readOKLine("OK")
}

// ListAllInfo returns attributes for songs in the library. Information about
// any song that is either inside or matches the passed in uri is returned.
// To get information about every song in the library, pass in "/".
func (c *mpd_Client) ListAllInfo(uri string) ([]mpd_Attrs, error) {
	id, err := c.cmd("listallinfo %s ", mpd_quote(uri))
	if err != nil {
		return nil, err
	}
	c.text.StartResponse(id)
	defer c.text.EndResponse(id)

	attrs := []mpd_Attrs{}
	inEntry := false
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}
		if line == "OK" {
			break
		} else if strings.HasPrefix(line, "file: ") { // new entry begins
			attrs = append(attrs, mpd_Attrs{})
			inEntry = true
		} else if strings.HasPrefix(line, "directory: ") {
			inEntry = false
		}

		if inEntry {
			i := strings.Index(line, ": ")
			if i < 0 {
				return nil, textproto.ProtocolError("can't parse line: " + line)
			}
			attrs[len(attrs)-1][line[0:i]] = line[i+2:]
		}
	}
	return attrs, nil
}

// ListInfo lists the contents of the directory URI using MPD's lsinfo command.
func (c *mpd_Client) ListInfo(uri string) ([]mpd_Attrs, error) {
	id, err := c.cmd("lsinfo %s", mpd_quote(uri))
	if err != nil {
		return nil, err
	}
	c.text.StartResponse(id)
	defer c.text.EndResponse(id)
	attrs := []mpd_Attrs{}
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}
		if line == "OK" {
			break
		}
		if strings.HasPrefix(line, "file: ") ||
			strings.HasPrefix(line, "directory: ") ||
			strings.HasPrefix(line, "playlist: ") {
			attrs = append(attrs, mpd_Attrs{})
		}
		i := strings.Index(line, ": ")
		if i < 0 {
			return nil, textproto.ProtocolError("can't parse line: " + line)
		}
		attrs[len(attrs)-1][strings.ToLower(line[0:i])] = line[i+2:]
	}
	return attrs, nil
}

// ReadComments reads "comments" (audio metadata) from the song URI using
// MPD's readcomments command.
func (c *mpd_Client) ReadComments(uri string) (mpd_Attrs, error) {
	return c.Command("readcomments %s", uri).Attrs()
}

// Find searches the library for songs and returns attributes for each matching song.
// The args are the raw arguments passed to MPD. For example, to search for
// songs that belong to a specific artist and album:
//
//	Find("artist", "Artist Name", "album", "Album Name")
//
// Searches are case sensitive. Use Search for case insensitive search.
func (c *mpd_Client) Find(args ...string) ([]mpd_Attrs, error) {
	return c.Command("find " + mpd_quoteArgs(args)).AttrsList("file")
}

// Search behaves exactly the same as Find, but the searches are not case sensitive.
func (c *mpd_Client) Search(args ...string) ([]mpd_Attrs, error) {
	return c.Command("search " + mpd_quoteArgs(args)).AttrsList("file")
}

// List searches the database for your query. You can use something simple like
// `artist` for your search, or something like `artist album <Album Name>` if
// you want the artist that has an album with a specified album name.
func (c *mpd_Client) List(args ...string) ([]string, error) {
	id, err := c.cmd("list " + mpd_quoteArgs(args))
	if err != nil {
		return nil, err
	}
	c.text.StartResponse(id)
	defer c.text.EndResponse(id)

	var ret []string
	for {
		line, err := c.readLine()
		if err != nil {
			return nil, err
		}

		i := strings.Index(line, ": ")
		if i > 0 {
			ret = append(ret, line[i+2:])
		} else if line == "OK" {
			break
		} else {
			return nil, textproto.ProtocolError("can't parse line: " + line)
		}
	}
	return ret, nil
}

// Output related commands.

// ListOutputs lists all configured outputs with their name, id & enabled state.
func (c *mpd_Client) ListOutputs() ([]mpd_Attrs, error) {
	return c.Command("outputs").AttrsList("outputid")
}

// EnableOutput enables the audio output with the given id.
func (c *mpd_Client) EnableOutput(id int) error {
	return c.Command("enableoutput %d", id).OK()
}

// DisableOutput disables the audio output with the given id.
func (c *mpd_Client) DisableOutput(id int) error {
	return c.Command("disableoutput %d", id).OK()
}

// Stored playlists related commands

// ListPlaylists lists all stored playlists.
func (c *mpd_Client) ListPlaylists() ([]mpd_Attrs, error) {
	return c.Command("listplaylists").AttrsList("playlist")
}

// PlaylistContents returns a list of attributes for songs in the specified
// stored playlist.
func (c *mpd_Client) PlaylistContents(name string) ([]mpd_Attrs, error) {
	return c.Command("listplaylistinfo %s", name).AttrsList("file")
}

// PlaylistLoad loads the specfied playlist into the current queue.
// If start and end are non-negative, only songs in this range are loaded.
func (c *mpd_Client) PlaylistLoad(name string, start, end int) error {
	if start < 0 || end < 0 {
		return c.Command("load %s", name).OK()
	}
	return c.Command("load %s %d:%d", name, start, end).OK()
}

// PlaylistAdd adds a song identified by uri to a stored playlist identified
// by name.
func (c *mpd_Client) PlaylistAdd(name string, uri string) error {
	return c.Command("playlistadd %s %s", name, uri).OK()
}

// PlaylistClear clears the specified playlist.
func (c *mpd_Client) PlaylistClear(name string) error {
	return c.Command("playlistclear %s", name).OK()
}

// PlaylistDelete deletes the song at position pos from the specified playlist.
func (c *mpd_Client) PlaylistDelete(name string, pos int) error {
	return c.Command("playlistdelete %s %d", name, pos).OK()
}

// PlaylistMove moves a song identified by id in a playlist identified by name
// to the position pos.
func (c *mpd_Client) PlaylistMove(name string, id, pos int) error {
	return c.Command("playlistmove %s %d %d", name, id, pos).OK()
}

// PlaylistRename renames the playlist identified by name to newName.
func (c *mpd_Client) PlaylistRename(name, newName string) error {
	return c.Command("rename %s %s", name, newName).OK()
}

// PlaylistRemove removes the playlist identified by name from the playlist
// directory.
func (c *mpd_Client) PlaylistRemove(name string) error {
	return c.Command("rm %s", name).OK()
}

// PlaylistSave saves the current playlist as name in the playlist directory.
func (c *mpd_Client) PlaylistSave(name string) error {
	return c.Command("save %s", name).OK()
}

// A Sticker represents a name/value pair associated to a song. Stickers
// are managed and shared by MPD clients, and MPD server does not assume
// any special meaning in them.
type mpd_Sticker struct {
	Name, Value string
}

func mpd_newSticker(name, value string) *mpd_Sticker {
	return &mpd_Sticker{
		Name:  name,
		Value: value,
	}
}

func mpd_parseSticker(s string) (*mpd_Sticker, error) {
	// Since '=' can appear in the sticker name and in the sticker value,
	// it's impossible to determine where the name ends and value starts.
	// Assume that '=' is more likely to occur in the value
	// (e.g. base64 encoded data -- see #39).
	i := strings.Index(s, "=")
	if i < 0 {
		return nil, textproto.ProtocolError("parsing sticker failed")
	}
	return mpd_newSticker(s[:i], s[i+1:]), nil
}

// StickerDelete deletes sticker for the song with given URI.
func (c *mpd_Client) StickerDelete(uri string, name string) error {
	return c.Command("sticker delete song %s %s", uri, name).OK()
}

// StickerFind finds songs inside directory with URI which have a sticker with given name.
// It returns a slice of URIs of matching songs and a slice of corresponding stickers.
func (c *mpd_Client) StickerFind(uri string, name string) ([]string, []mpd_Sticker, error) {
	attrs, err := c.Command("sticker find song %s %s", uri, name).AttrsList("file")
	if err != nil {
		return nil, nil, err
	}
	files := make([]string, len(attrs))
	stks := make([]mpd_Sticker, len(attrs))
	for i, attr := range attrs {
		if _, ok := attr["file"]; !ok {
			return nil, nil, textproto.ProtocolError("file attribute not found")
		}
		if _, ok := attr["sticker"]; !ok {
			return nil, nil, textproto.ProtocolError("sticker attribute not found")
		}
		files[i] = attr["file"]
		stk, err := mpd_parseSticker(attr["sticker"])
		if err != nil {
			return nil, nil, err
		}
		stks[i] = *stk
	}
	return files, stks, nil
}

// StickerGet gets sticker value for the song with given URI.
func (c *mpd_Client) StickerGet(uri string, name string) (*mpd_Sticker, error) {
	attrs, err := c.Command("sticker get song %s %s", uri, name).Attrs()
	if err != nil {
		return nil, err
	}
	attr, ok := attrs["sticker"]
	if !ok {
		return nil, textproto.ProtocolError("sticker not found")
	}
	stk, err := mpd_parseSticker(attr)
	if stk == nil {
		return nil, err
	}
	return stk, nil
}

// StickerList returns a slice of stickers for the song with given URI.
func (c *mpd_Client) StickerList(uri string) ([]mpd_Sticker, error) {
	attrs, err := c.Command("sticker list song %s", uri).AttrsList("sticker")
	if err != nil {
		return nil, err
	}
	stks := make([]mpd_Sticker, len(attrs))
	for i, attr := range attrs {
		s, ok := attr["sticker"]
		if !ok {
			return nil, textproto.ProtocolError("sticker attribute not found")
		}
		stk, err := mpd_parseSticker(s)
		if err != nil {
			return nil, err
		}
		stks[i] = *stk
	}
	return stks, nil
}

// StickerSet sets sticker value for the song with given URI.
func (c *mpd_Client) StickerSet(uri string, name string, value string) error {
	return c.Command("sticker set song %s %s %s", uri, name, value).OK()
}

// AlbumArt retrieves an album artwork image for a song with the given URI using MPD's albumart command.
func (c *mpd_Client) AlbumArt(uri string) ([]byte, error) {
	offset := 0
	var data []byte
	for {
		// Read the data in chunks
		chunk, size, err := c.Command("albumart %s %d", uri, offset).Binary()
		if err != nil {
			return nil, err
		}

		// Accumulate the data
		data = append(data, chunk...)
		offset = len(data)
		if offset >= size {
			break
		}
	}
	return data, nil
}

type mpd_cmdType uint

const (
	mpd_cmdNoReturn mpd_cmdType = iota
	mpd_cmdAttrReturn
	mpd_cmdIDReturn
)

type mpd_command struct {
	cmd     string
	promise interface{}
	typeOf  mpd_cmdType
}

// CommandList is for batch/mass MPD commands.
// See http://www.musicpd.org/doc/protocol/command_lists.html
// for more details.
type mpd_CommandList struct {
	client *mpd_Client
	cmdQ   *list.List
}

// PromisedAttrs is a set of promised attributes (to be) returned by MPD.
type mpd_PromisedAttrs struct {
	attrs    mpd_Attrs
	computed bool
}

func mpd_newPromisedAttrs() *mpd_PromisedAttrs {
	return &mpd_PromisedAttrs{attrs: make(mpd_Attrs), computed: false}
}

// PromisedID is a promised identifier (to be) returned by MPD.
type mpd_PromisedID int

// Value is a convenience method for ensuring that a promise
// has been computed, returning the Attrs.
func (pa *mpd_PromisedAttrs) Value() (mpd_Attrs, error) {
	if !pa.computed {
		return nil, errors.New("value has not been computed yet")
	}
	return pa.attrs, nil
}

// Value is a convenience method for ensuring that a promise
// has been computed, returning the ID.
func (pi *mpd_PromisedID) Value() (int, error) {
	if *pi == -1 {
		return -1, errors.New("value has not been computed yet")
	}
	return int(*pi), nil
}

// BeginCommandList creates a new CommandList structure using
// this connection.
func (c *mpd_Client) BeginCommandList() *mpd_CommandList {
	return &mpd_CommandList{c, list.New()}
}

// Ping sends a no-op message to MPD. It's useful for keeping the connection alive.
func (cl *mpd_CommandList) Ping() {
	cl.cmdQ.PushBack(&mpd_command{"ping", nil, mpd_cmdNoReturn})
}

// CurrentSong returns information about the current song in the playlist.
func (cl *mpd_CommandList) CurrentSong() *mpd_PromisedAttrs {
	pa := mpd_newPromisedAttrs()
	cl.cmdQ.PushBack(&mpd_command{"currentsong", pa, mpd_cmdAttrReturn})
	return pa
}

// Status returns information about the current status of MPD.
func (cl *mpd_CommandList) Status() *mpd_PromisedAttrs {
	pa := mpd_newPromisedAttrs()
	cl.cmdQ.PushBack(&mpd_command{"status", pa, mpd_cmdAttrReturn})
	return pa
}

//
// Playback control
//

// Next plays next song in the playlist.
func (cl *mpd_CommandList) Next() {
	cl.cmdQ.PushBack(&mpd_command{"next", nil, mpd_cmdNoReturn})
}

// Pause pauses playback if pause is true; resumes playback otherwise.
func (cl *mpd_CommandList) Pause(pause bool) {
	if pause {
		cl.cmdQ.PushBack(&mpd_command{"pause 1", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{"pause 0", nil, mpd_cmdNoReturn})
	}
}

// Play starts playing the song at playlist position pos. If pos is negative,
// start playing at the current position in the playlist.
func (cl *mpd_CommandList) Play(pos int) {
	if pos < 0 {
		cl.cmdQ.PushBack(&mpd_command{"play", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("play %d", pos), nil, mpd_cmdNoReturn})
	}
}

// PlayID plays the song identified by id. If id is negative, start playing
// at the currect position in playlist.
func (cl *mpd_CommandList) PlayID(id int) {
	if id < 0 {
		cl.cmdQ.PushBack(&mpd_command{"playid", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("playid %d", id), nil, mpd_cmdNoReturn})
	}
}

// Previous plays previous song in the playlist.
func (cl *mpd_CommandList) Previous() {
	cl.cmdQ.PushBack(&mpd_command{"previous", nil, mpd_cmdNoReturn})
}

// Seek seeks to the position time (in seconds) of the song at playlist position pos.
func (cl *mpd_CommandList) Seek(pos, time int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("seek %d %d", pos, time), nil, mpd_cmdNoReturn})
}

// SeekID is identical to Seek except the song is identified by it's id
// (not position in playlist).
func (cl *mpd_CommandList) SeekID(id, time int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("seekid %d %d", id, time), nil, mpd_cmdNoReturn})
}

// Stop stops playback.
func (cl *mpd_CommandList) Stop() {
	cl.cmdQ.PushBack(&mpd_command{"stop", nil, mpd_cmdNoReturn})
}

// SetVolume sets the MPD volume level.
func (cl *mpd_CommandList) SetVolume(volume int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("setvol %d", volume), nil, mpd_cmdNoReturn})
}

// Random enables random playback, if random is true, disables it otherwise.
func (cl *mpd_CommandList) Random(random bool) {
	if random {
		cl.cmdQ.PushBack(&mpd_command{"random 1", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{"random 0", nil, mpd_cmdNoReturn})
	}
}

// Repeat enables repeat mode, if repeat is true, disables it otherwise.
func (cl *mpd_CommandList) Repeat(repeat bool) {
	if repeat {
		cl.cmdQ.PushBack(&mpd_command{"repeat 1", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{"repeat 0", nil, mpd_cmdNoReturn})
	}
}

// Single enables single song mode, if single is true, disables it otherwise.
func (cl *mpd_CommandList) Single(single bool) {
	if single {
		cl.cmdQ.PushBack(&mpd_command{"single 1", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{"single 0", nil, mpd_cmdNoReturn})
	}
}

// Consume enables consume mode, if consume is true, disables it otherwise.
func (cl *mpd_CommandList) Consume(consume bool) {
	if consume {
		cl.cmdQ.PushBack(&mpd_command{"consume 1", nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{"consume 0", nil, mpd_cmdNoReturn})
	}
}

//
// Playlist related functions
//

// SetPriority sets the priority for songs in the playlist. If both start and
// end are non-negative, it updates those at positions in range [start, end).
// If end is negative, it updates the song at position start.
func (cl *mpd_CommandList) SetPriority(priority, start, end int) error {
	if start < 0 {
		return errors.New("negative start index")
	}
	if end < 0 {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("prio %d %d", priority, start), nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("prio %d %d:%d", priority, start, end), nil, mpd_cmdNoReturn})
	}
	return nil
}

// SetPriorityID sets the priority for the song identified by id.
func (cl *mpd_CommandList) SetPriorityID(priority, id int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("prioid %d %d", priority, id), nil, mpd_cmdNoReturn})
}

// Delete deletes songs from playlist. If both start and end are positive,
// it deletes those at positions in range [start, end). If end is negative,
// it deletes the song at position start.
func (cl *mpd_CommandList) Delete(start, end int) error {
	if start < 0 {
		return errors.New("negative start index")
	}
	if end < 0 {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("delete %d", start), nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("delete %d:%d", start, end), nil, mpd_cmdNoReturn})
	}
	return nil
}

// DeleteID deletes the song identified by id.
func (cl *mpd_CommandList) DeleteID(id int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("deleteid %d", id), nil, mpd_cmdNoReturn})
}

// Move moves the songs between the positions start and end to the new position
// position. If end is negative, only the song at position start is moved.
func (cl *mpd_CommandList) Move(start, end, position int) error {
	if start < 0 {
		return errors.New("negative start index")
	}
	if end < 0 {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("move %d %d", start, position), nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("move %d:%d %d", start, end, position), nil, mpd_cmdNoReturn})
	}
	return nil
}

// MoveID moves songid to position on the playlist.
func (cl *mpd_CommandList) MoveID(songid, position int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("moveid %d %d", songid, position), nil, mpd_cmdNoReturn})
}

// Add adds the file/directory uri to playlist. Directories add recursively.
func (cl *mpd_CommandList) Add(uri string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("add %s", mpd_quote(uri)), nil, mpd_cmdNoReturn})
}

// AddID adds the file/directory uri to playlist and returns the identity
// id of the song added. If pos is positive, the song is added to position
// pos.
func (cl *mpd_CommandList) AddID(uri string, pos int) *mpd_PromisedID {
	var id mpd_PromisedID = -1
	if pos >= 0 {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("addid %s %d", mpd_quote(uri), pos), &id, mpd_cmdIDReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("addid %s", mpd_quote(uri)), &id, mpd_cmdIDReturn})
	}
	return &id
}

// Clear clears the current playlist.
func (cl *mpd_CommandList) Clear() {
	cl.cmdQ.PushBack(&mpd_command{"clear", nil, mpd_cmdNoReturn})
}

// Shuffle shuffles the tracks from position start to position end in the
// current playlist. If start or end is negative, the whole playlist is
// shuffled.
func (cl *mpd_CommandList) Shuffle(start, end int) {
	if start < 0 || end < 0 {
		cl.cmdQ.PushBack(&mpd_command{"shuffle", nil, mpd_cmdNoReturn})
		return
	}
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("shuffle %d:%d", start, end), nil, mpd_cmdNoReturn})
}

// Update updates MPD's database: find new files, remove deleted files, update
// modified files. uri is a particular directory or file to update. If it is an
// empty string, everything is updated.
func (cl *mpd_CommandList) Update(uri string) (attrs *mpd_PromisedAttrs) {
	attrs = mpd_newPromisedAttrs()
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("update %s", mpd_quote(uri)), attrs, mpd_cmdAttrReturn})
	return
}

// Stored playlists related commands.

// PlaylistLoad loads the specfied playlist into the current queue.
// If start and end are non-negative, only songs in this range are loaded.
func (cl *mpd_CommandList) PlaylistLoad(name string, start, end int) {
	if start < 0 || end < 0 {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("load %s", mpd_quote(name)), nil, mpd_cmdNoReturn})
	} else {
		cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("load %s %d:%d", mpd_quote(name), start, end), nil, mpd_cmdNoReturn})
	}
}

// PlaylistAdd adds a song identified by uri to a stored playlist identified
// by name.
func (cl *mpd_CommandList) PlaylistAdd(name string, uri string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("playlistadd %s %s", mpd_quote(name), mpd_quote(uri)), nil, mpd_cmdNoReturn})
}

// PlaylistClear clears the specified playlist.
func (cl *mpd_CommandList) PlaylistClear(name string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("playlistclear %s", mpd_quote(name)), nil, mpd_cmdNoReturn})
}

// PlaylistDelete deletes the song at position pos from the specified playlist.
func (cl *mpd_CommandList) PlaylistDelete(name string, pos int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("playlistdelete %s %d", mpd_quote(name), pos), nil, mpd_cmdNoReturn})
}

// PlaylistMove moves a song identified by id in a playlist identified by name
// to the position pos.
func (cl *mpd_CommandList) PlaylistMove(name string, id, pos int) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("playlistmove %s %d %d", mpd_quote(name), id, pos), nil, mpd_cmdNoReturn})
}

// PlaylistRename renames the playlist identified by name to newName.
func (cl *mpd_CommandList) PlaylistRename(name, newName string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("rename %s %s", mpd_quote(name), mpd_quote(newName)), nil, mpd_cmdNoReturn})
}

// PlaylistRemove removes the playlist identified by name from the playlist
// directory.
func (cl *mpd_CommandList) PlaylistRemove(name string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("rm %s", mpd_quote(name)), nil, mpd_cmdNoReturn})
}

// PlaylistSave saves the current playlist as name in the playlist directory.
func (cl *mpd_CommandList) PlaylistSave(name string) {
	cl.cmdQ.PushBack(&mpd_command{fmt.Sprintf("save %s", mpd_quote(name)), nil, mpd_cmdNoReturn})
}

// End executes the command list.
func (cl *mpd_CommandList) End() error {

	// Tell MPD to start an OK command list:
	beginID, beginErr := cl.client.cmd("command_list_ok_begin")
	if beginErr != nil {
		return beginErr
	}
	cl.client.text.StartResponse(beginID)
	cl.client.text.EndResponse(beginID)

	// Ensure the queue is cleared regardless.
	defer cl.cmdQ.Init()

	// Issue all of the queued up commands in the list:
	for e := cl.cmdQ.Front(); e != nil; e = e.Next() {
		cmdID, cmdErr := cl.client.cmd(e.Value.(*mpd_command).cmd)
		if cmdErr != nil {
			return cmdErr
		}
		cl.client.text.StartResponse(cmdID)
		cl.client.text.EndResponse(cmdID)
	}

	// Tell MPD to end the command list and do the operations.
	endID, endErr := cl.client.cmd("command_list_end")
	if endErr != nil {
		return endErr
	}
	cl.client.text.StartResponse(endID)
	defer cl.client.text.EndResponse(endID)

	// Get the responses back and check for errors:
	for e := cl.cmdQ.Front(); e != nil; e = e.Next() {
		switch e.Value.(*mpd_command).typeOf {

		case mpd_cmdNoReturn:
			if err := cl.client.readOKLine("list_OK"); err != nil {
				return err
			}

		case mpd_cmdAttrReturn:
			a, aErr := cl.client.readAttrs("list_OK")
			if aErr != nil {
				return aErr
			}
			pa := e.Value.(*mpd_command).promise.(*mpd_PromisedAttrs)
			pa.attrs = a
			pa.computed = true

		case mpd_cmdIDReturn:
			a, aErr := cl.client.readAttrs("list_OK")
			if aErr != nil {
				return aErr
			}
			rid, ridErr := strconv.Atoi(a["Id"])
			if ridErr != nil {
				return ridErr
			}
			*e.Value.(*mpd_command).promise.(*mpd_PromisedID) = mpd_PromisedID(rid)

		}
	}

	// Finalize the command list with the last OK:
	return cl.client.readOKLine("OK")
}

// Quoted is a string that do no need to be quoted.
type mpd_Quoted string

// Command returns a command that can be sent to MPD sever.
// It enables low-level access to MPD protocol and should be avoided if
// the user is not familiar with MPD protocol.
//
// Strings in args are automatically quoted so that spaces are preserved.
// Pass strings as Quoted type if this is not desired.
func (c *mpd_Client) Command(format string, args ...interface{}) *mpd_Command {
	for i := range args {
		switch s := args[i].(type) {
		case mpd_Quoted: // ignore
		case string:
			args[i] = mpd_quote(s)
		}
	}
	return &mpd_Command{
		client: c,
		cmd:    fmt.Sprintf(format, args...),
	}
}

// A Command represents a MPD command.
type mpd_Command struct {
	client *mpd_Client
	cmd    string
}

// String returns the encoded command.
func (cmd *mpd_Command) String() string {
	return cmd.cmd
}

// OK sends command to server and checks for error.
func (cmd *mpd_Command) OK() error {
	id, err := cmd.client.cmd("%v", cmd.cmd)
	if err != nil {
		return err
	}
	cmd.client.text.StartResponse(id)
	defer cmd.client.text.EndResponse(id)
	return cmd.client.readOKLine("OK")
}

// Attrs sends command to server and reads attributes returned in response.
func (cmd *mpd_Command) Attrs() (mpd_Attrs, error) {
	id, err := cmd.client.cmd(cmd.cmd)
	if err != nil {
		return nil, err
	}
	cmd.client.text.StartResponse(id)
	defer cmd.client.text.EndResponse(id)
	return cmd.client.readAttrs("OK")
}

// AttrsList sends command to server and reads a list of attributes returned in response.
// Each attribute group starts with key startKey.
func (cmd *mpd_Command) AttrsList(startKey string) ([]mpd_Attrs, error) {
	id, err := cmd.client.cmd(cmd.cmd)
	if err != nil {
		return nil, err
	}
	cmd.client.text.StartResponse(id)
	defer cmd.client.text.EndResponse(id)
	return cmd.client.readAttrsList(startKey)
}

// Strings sends command to server and reads a list of strings returned in response.
// Each string have the key key.
func (cmd *mpd_Command) Strings(key string) ([]string, error) {
	id, err := cmd.client.cmd(cmd.cmd)
	if err != nil {
		return nil, err
	}
	cmd.client.text.StartResponse(id)
	defer cmd.client.text.EndResponse(id)
	return cmd.client.readList(key)
}

// Binary sends command to server and reads its binary response, returning the data and its total size (which can be
// greater than the returned chunk).
func (cmd *mpd_Command) Binary() ([]byte, int, error) {
	id, err := cmd.client.cmd(cmd.cmd)
	if err != nil {
		return nil, 0, err
	}
	cmd.client.text.StartResponse(id)
	defer cmd.client.text.EndResponse(id)
	return cmd.client.readBinary()
}

// Watcher represents a MPD client connection that can be watched for events.
type mpd_Watcher struct {
	conn  *mpd_Client   // client connection to MPD
	exit  chan bool     // channel used to ask loop to terminate
	done  chan bool     // channel indicating loop has terminated
	names chan []string // channel to set new subsystems to watch
	Event chan string   // event channel
	Error chan error    // error channel
}

// NewWatcher connects to MPD server and watches for changes in subsystems
// names. If no subsystem is specified, all changes are reported.
//
// See http://www.musicpd.org/doc/protocol/command_reference.html#command_idle
// for valid subsystem names.
func mpd_NewWatcher(net, addr, passwd string, names ...string) (w *mpd_Watcher, err error) {
	conn, err := mpd_DialAuthenticated(net, addr, passwd)
	if err != nil {
		return
	}
	w = &mpd_Watcher{
		conn:  conn,
		Event: make(chan string),
		Error: make(chan error),
		done:  make(chan bool),
		// Buffer channels to avoid race conditions with noIdle
		names: make(chan []string, 1),
		exit:  make(chan bool, 1),
	}
	go w.watch(names...)
	return
}

func (w *mpd_Watcher) watch(names ...string) {
	defer w.closeChans()

	// We can block in two places: idle and sending on Event/Error channels.
	// We need to check w.exit and w.names after each.
	for {
		changed, err := w.conn.idle(names...)
		select {
		case <-w.exit:
			// If Close interrupted idle with a noidle, and we don't
			// exit now, we will block trying to send on Event/Error.
			return
		case names = <-w.names:
			// Received new subsystems to watch. Ignore results.
			changed = []string{}
			err = nil
		default: // continue
		}

		switch {
		case err != nil:
			w.Error <- err
		default:
			for _, name := range changed {
				w.Event <- name
			}
		}
		select {
		case <-w.exit:
			// If Close unblocks us from sending on Event/Error channels,
			// we should exit now because noidle might be sent out
			// before we get to idle.
			return
		case names = <-w.names:
			// If method Subsystems unblocks us from sending on Event/Error
			// channels, the next call to idle should be on the new names.
		default: // continue
		}
	}
}

func (w *mpd_Watcher) closeChans() {
	close(w.Event)
	close(w.Error)
	close(w.names)
	close(w.exit)
	close(w.done)
}

func (w *mpd_Watcher) consume() {
	for {
		select {
		case <-w.Event:
		case <-w.Error:
		default:
			return
		}
	}
}

// Subsystems interrupts watching current subsystems, consumes all
// outstanding values from Event and Error channels, and then
// changes the subsystems to watch for to names.
func (w *mpd_Watcher) Subsystems(names ...string) {
	w.names <- names
	w.consume()
	w.conn.noIdle()
}

// Close closes Event and Error channels, and the connection to MPD server.
func (w *mpd_Watcher) Close() error {
	w.exit <- true
	w.consume()
	w.conn.noIdle()

	<-w.done // wait for idle to finish and channels to close
	// At this point, watch goroutine has ended,
	// so it's safe to close connection.
	return w.conn.Close()
}
